import Logger from '../utils/Logger.js';\n\n/**\n * Global teardown for Playwright tests\n * Follows Single Responsibility Principle\n */\nasync function globalTeardown() {\n  const logger = Logger.child({ module: 'GlobalTeardown' });\n  \n  try {\n    logger.info('Starting global teardown');\n    \n    // Cleanup temporary files\n    await cleanupTempFiles();\n    \n    // Generate test summary\n    await generateTestSummary();\n    \n    // Cleanup authentication files\n    await cleanupAuthFiles();\n    \n    logger.info('Global teardown completed successfully');\n    \n  } catch (error) {\n    logger.error('Global teardown failed', { error: error.message });\n    // Don't throw as teardown failures shouldn't fail the test run\n  }\n}\n\n/**\n * Cleanup temporary files\n */\nasync function cleanupTempFiles() {\n  const logger = Logger.child({ module: 'TempCleanup' });\n  \n  try {\n    const fs = await import('fs');\n    const path = await import('path');\n    \n    const tempDirs = [\n      'temp',\n      '.tmp',\n      'downloads'\n    ];\n    \n    for (const dir of tempDirs) {\n      const dirPath = path.resolve(dir);\n      if (fs.existsSync(dirPath)) {\n        fs.rmSync(dirPath, { recursive: true, force: true });\n        logger.info('Cleaned up temporary directory', { path: dirPath });\n      }\n    }\n    \n  } catch (error) {\n    logger.warn('Temp file cleanup failed', { error: error.message });\n  }\n}\n\n/**\n * Generate test summary\n */\nasync function generateTestSummary() {\n  const logger = Logger.child({ module: 'TestSummary' });\n  \n  try {\n    const fs = await import('fs');\n    const path = await import('path');\n    \n    const resultsPath = path.resolve('test-results/results.json');\n    \n    if (fs.existsSync(resultsPath)) {\n      const results = JSON.parse(fs.readFileSync(resultsPath, 'utf8'));\n      \n      const summary = {\n        timestamp: new Date().toISOString(),\n        total: results.suites?.reduce((acc, suite) => acc + suite.specs?.length || 0, 0) || 0,\n        passed: 0,\n        failed: 0,\n        skipped: 0,\n        duration: results.stats?.duration || 0\n      };\n      \n      // Calculate test counts\n      results.suites?.forEach(suite => {\n        suite.specs?.forEach(spec => {\n          spec.tests?.forEach(test => {\n            switch (test.status) {\n              case 'passed':\n                summary.passed++;\n                break;\n              case 'failed':\n                summary.failed++;\n                break;\n              case 'skipped':\n                summary.skipped++;\n                break;\n            }\n          });\n        });\n      });\n      \n      // Write summary\n      const summaryPath = path.resolve('test-results/summary.json');\n      fs.writeFileSync(summaryPath, JSON.stringify(summary, null, 2));\n      \n      logger.info('Test summary generated', summary);\n    }\n    \n  } catch (error) {\n    logger.warn('Test summary generation failed', { error: error.message });\n  }\n}\n\n/**\n * Cleanup authentication files\n */\nasync function cleanupAuthFiles() {\n  const logger = Logger.child({ module: 'AuthCleanup' });\n  \n  try {\n    const fs = await import('fs');\n    const path = await import('path');\n    \n    const authFiles = [\n      'test-results/auth.json',\n      'test-results/.auth'\n    ];\n    \n    for (const file of authFiles) {\n      const filePath = path.resolve(file);\n      if (fs.existsSync(filePath)) {\n        fs.unlinkSync(filePath);\n        logger.info('Cleaned up auth file', { path: filePath });\n      }\n    }\n    \n  } catch (error) {\n    logger.warn('Auth file cleanup failed', { error: error.message });\n  }\n}\n\nexport default globalTeardown;