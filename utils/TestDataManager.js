/**\n * Test Data Manager implementing Strategy Pattern\n * Follows Single Responsibility and Open/Closed Principles\n */\n\n/**\n * Abstract data source interface\n */\nclass DataSource {\n  async getData(key) {\n    throw new Error('getData method must be implemented');\n  }\n\n  async setData(key, value) {\n    throw new Error('setData method must be implemented');\n  }\n}\n\n/**\n * JSON file data source\n */\nclass JsonDataSource extends DataSource {\n  constructor(filePath) {\n    super();\n    this.filePath = filePath;\n    this._cache = new Map();\n  }\n\n  async getData(key) {\n    if (this._cache.has(key)) {\n      return this._cache.get(key);\n    }\n\n    try {\n      const fs = await import('fs');\n      const path = await import('path');\n      \n      const fullPath = path.resolve(this.filePath);\n      \n      if (!fs.existsSync(fullPath)) {\n        return null;\n      }\n\n      const data = JSON.parse(fs.readFileSync(fullPath, 'utf8'));\n      const value = this._getNestedValue(data, key);\n      \n      this._cache.set(key, value);\n      return value;\n    } catch (error) {\n      console.warn(`Failed to read data for key ${key}:`, error.message);\n      return null;\n    }\n  }\n\n  async setData(key, value) {\n    try {\n      const fs = await import('fs');\n      const path = await import('path');\n      \n      const fullPath = path.resolve(this.filePath);\n      let data = {};\n      \n      if (fs.existsSync(fullPath)) {\n        data = JSON.parse(fs.readFileSync(fullPath, 'utf8'));\n      }\n      \n      this._setNestedValue(data, key, value);\n      \n      // Ensure directory exists\n      const dir = path.dirname(fullPath);\n      if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true });\n      }\n      \n      fs.writeFileSync(fullPath, JSON.stringify(data, null, 2));\n      this._cache.set(key, value);\n    } catch (error) {\n      throw new Error(`Failed to set data for key ${key}: ${error.message}`);\n    }\n  }\n\n  _getNestedValue(obj, key) {\n    return key.split('.').reduce((current, prop) => current?.[prop], obj);\n  }\n\n  _setNestedValue(obj, key, value) {\n    const keys = key.split('.');\n    const lastKey = keys.pop();\n    const target = keys.reduce((current, prop) => {\n      if (!current[prop]) current[prop] = {};\n      return current[prop];\n    }, obj);\n    target[lastKey] = value;\n  }\n}\n\n/**\n * Environment data source\n */\nclass EnvironmentDataSource extends DataSource {\n  async getData(key) {\n    return process.env[key.toUpperCase().replace(/\\./g, '_')] || null;\n  }\n\n  async setData(key, value) {\n    process.env[key.toUpperCase().replace(/\\./g, '_')] = value;\n  }\n}\n\n/**\n * In-memory data source\n */\nclass MemoryDataSource extends DataSource {\n  constructor() {\n    super();\n    this._data = new Map();\n  }\n\n  async getData(key) {\n    return this._data.get(key) || null;\n  }\n\n  async setData(key, value) {\n    this._data.set(key, value);\n  }\n\n  clear() {\n    this._data.clear();\n  }\n}\n\n/**\n * Test Data Manager with multiple data sources\n */\nclass TestDataManager {\n  constructor() {\n    if (TestDataManager.instance) {\n      return TestDataManager.instance;\n    }\n\n    this._dataSources = [];\n    this._defaultData = this._initializeDefaultData();\n    \n    // Initialize default data sources\n    this.addDataSource(new EnvironmentDataSource());\n    this.addDataSource(new JsonDataSource('test-data/users.json'));\n    this.addDataSource(new MemoryDataSource());\n    \n    TestDataManager.instance = this;\n  }\n\n  /**\n   * Initialize default test data\n   */\n  _initializeDefaultData() {\n    return {\n      users: {\n        valid: {\n          email: 'JafTester1@gmail.com',\n          password: 'Pl@y1234',\n          firstName: 'Test',\n          lastName: 'User'\n        },\n        invalid: {\n          email: 'invalid@test.com',\n          password: 'wrongpass'\n        },\n        admin: {\n          email: 'admin@test.com',\n          password: 'admin123'\n        }\n      },\n      products: {\n        sample: {\n          name: 'Sample Product',\n          price: 99.99,\n          category: 'Electronics'\n        }\n      },\n      urls: {\n        base: 'https://rahulshettyacademy.com/client/#/',\n        login: 'https://rahulshettyacademy.com/loginpagePractise/',\n        api: 'https://rahulshettyacademy.com/api'\n      }\n    };\n  }\n\n  /**\n   * Add data source\n   * @param {DataSource} dataSource - Data source to add\n   */\n  addDataSource(dataSource) {\n    if (!(dataSource instanceof DataSource)) {\n      throw new Error('Data source must extend DataSource class');\n    }\n    this._dataSources.push(dataSource);\n  }\n\n  /**\n   * Get data from sources (first found wins)\n   * @param {string} key - Data key (supports dot notation)\n   * @returns {Promise<*>} Data value\n   */\n  async getData(key) {\n    // Try data sources first\n    for (const source of this._dataSources) {\n      try {\n        const value = await source.getData(key);\n        if (value !== null && value !== undefined) {\n          return value;\n        }\n      } catch (error) {\n        console.warn(`Data source error for key ${key}:`, error.message);\n      }\n    }\n\n    // Fall back to default data\n    return this._getNestedValue(this._defaultData, key);\n  }\n\n  /**\n   * Set data in memory source\n   * @param {string} key - Data key\n   * @param {*} value - Data value\n   */\n  async setData(key, value) {\n    const memorySource = this._dataSources.find(source => source instanceof MemoryDataSource);\n    if (memorySource) {\n      await memorySource.setData(key, value);\n    } else {\n      throw new Error('No memory data source available');\n    }\n  }\n\n  /**\n   * Get user data\n   * @param {string} userType - Type of user (valid, invalid, admin)\n   * @returns {Promise<Object>} User data\n   */\n  async getUser(userType = 'valid') {\n    return await this.getData(`users.${userType}`);\n  }\n\n  /**\n   * Get product data\n   * @param {string} productType - Type of product\n   * @returns {Promise<Object>} Product data\n   */\n  async getProduct(productType = 'sample') {\n    return await this.getData(`products.${productType}`);\n  }\n\n  /**\n   * Get URL\n   * @param {string} urlType - Type of URL (base, login, api)\n   * @returns {Promise<string>} URL\n   */\n  async getUrl(urlType = 'base') {\n    return await this.getData(`urls.${urlType}`);\n  }\n\n  /**\n   * Generate random user data\n   * @returns {Object} Random user data\n   */\n  generateRandomUser() {\n    const timestamp = Date.now();\n    return {\n      email: `test${timestamp}@example.com`,\n      password: `Pass${timestamp}!`,\n      firstName: `Test${timestamp}`,\n      lastName: 'User'\n    };\n  }\n\n  /**\n   * Generate test data for specific scenario\n   * @param {string} scenario - Test scenario name\n   * @returns {Object} Generated test data\n   */\n  generateScenarioData(scenario) {\n    const generators = {\n      'login': () => ({\n        validUser: this.generateRandomUser(),\n        invalidUser: { email: 'invalid@test.com', password: 'wrong' }\n      }),\n      'registration': () => ({\n        newUser: {\n          ...this.generateRandomUser(),\n          confirmPassword: 'Pass' + Date.now() + '!'\n        }\n      }),\n      'checkout': () => ({\n        shippingAddress: {\n          street: '123 Test St',\n          city: 'Test City',\n          zipCode: '12345',\n          country: 'US'\n        },\n        paymentInfo: {\n          cardNumber: '4111111111111111',\n          expiryDate: '12/25',\n          cvv: '123'\n        }\n      })\n    };\n\n    const generator = generators[scenario];\n    if (!generator) {\n      throw new Error(`No generator found for scenario: ${scenario}`);\n    }\n\n    return generator();\n  }\n\n  /**\n   * Clear all cached data\n   */\n  clearCache() {\n    this._dataSources.forEach(source => {\n      if (source instanceof JsonDataSource) {\n        source._cache.clear();\n      } else if (source instanceof MemoryDataSource) {\n        source.clear();\n      }\n    });\n  }\n\n  /**\n   * Get nested value from object\n   */\n  _getNestedValue(obj, key) {\n    if (!key) return obj;\n    return key.split('.').reduce((current, prop) => current?.[prop], obj);\n  }\n}\n\n// Export classes and singleton instance\nexport { \n  TestDataManager, \n  DataSource, \n  JsonDataSource, \n  EnvironmentDataSource, \n  MemoryDataSource \n};\n\nexport default new TestDataManager();